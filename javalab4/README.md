# Отчет по Лабораторной работе №4
**Студент:** Чеповецкий Александр ИТ-7  
**Тема:** Обобщенные типы (Generics) и методы

---

## Задание 1. Обобщенные типы

### Задача 1. Обобщенная коробка
**Текст задачи:**  
Создать сущность «Коробка» (`Box`), способную хранить один объект любого типа. Объект можно положить только в пустую коробку, а при извлечении ссылка в коробке должна обнуляться.  
**Алгоритм решения:**  
1. Создать класс `Box<T>`, где `T` — универсальный параметр типа.  
2. Реализовать метод `put(T item)`: добавить проверку на наличие объекта. Если поле не пустое, выбрасывать исключение.  
3. Реализовать метод `get()`: временно сохранить объект, занулить поле `item` и вернуть сохраненное значение.  
4. Добавить метод `isFull()`, возвращающий состояние коробки (`true`, если внутри есть объект).

### Задача 2. Без null (Хранилище)
**Текст задачи:**  
Создать неизменяемое «Хранилище» (`Storage`), которое может хранить любой объект, включая `null`. При получении значения предусмотреть возврат альтернативного значения, если в хранилище лежит `null`.  
**Алгоритм решения:**  
1. Создать класс `Storage<T>` с финальным полем типа `T`.  
2. Инициализировать поле один раз через конструктор.  
3. Реализовать метод `getValue(T alternative)`: если значение в поле равно `null`, возвращать `alternative`, иначе — само значение.

---

## Задание 2. Параметризация

### Задача 3. Начало отсчета
**Текст задачи:**  
Написать метод, который принимает коробку и кладет в нее объект `Point3D`. Метод должен быть совместим с коробками, типизированными как сам `Point3D`, так и его родительские классы.  
**Алгоритм решения:**  
1. Использовать механизм **Lower Bounded Wildcards**: метод должен принимать `Box<? super Point3D>`.  
2. Это позволит передавать в метод `Box<Point3D>`, `Box<Point>` или `Box<Object>`.  
3. Внутри метода создать экземпляр `Point3D` и поместить его в коробку через метод `put()`.

---

## Задание 3. Обобщенные методы

### Задача 1. Функция (Map)
**Текст задачи:**  
Разработать метод, преобразующий список элементов типа `T` в список элементов типа `P` с помощью заданной функции преобразования.  
**Алгоритм решения:**  
1. Описать интерфейс `Transformer<T, P>` с методом `apply`, который принимает `T` и возвращает `P`.  
2. Создать метод `map`, принимающий `List<T>` и объект трансформатора.  
3. В цикле проходить по исходному списку, применять трансформацию к каждому элементу и добавлять результат в новый `ArrayList<P>`.

### Задача 2. Фильтр (Filter)
**Текст задачи:**  
Реализовать метод, который фильтрует исходный список и возвращает новый, содержащий только те элементы, которые удовлетворяют заданному условию.  
**Алгоритм решения:**  
1. Создать интерфейс `Filter<T>` с методом `test`, возвращающим `boolean`.  
2. В методе фильтрации создать пустой результирующий список.  
3. Пройти по элементам входного списка: если метод `test` возвращает `true`, добавить элемент в результат.

### Задача 3. Сокращение (Reduce)
**Текст задачи:**  
Написать метод, который сводит (агрегирует) список элементов к одному единственному значению.  
**Алгоритм решения:**  
1. Описать интерфейс `Reducer<T>` с методом `reduce(T t1, T t2)`.  
2. Метод должен принимать список и начальное значение (`identity`).  
3. Если список пуст, возвращать `identity`. Иначе — последовательно применять операцию редукции ко всем элементам списка, накапливая результат.

### Задача 4. Коллекционирование (Collect)
**Текст задачи:**  
Реализовать универсальный метод, который переносит элементы из списка в любую другую коллекцию (множество, очередь и т.д.).  
**Алгоритм решения:**  
1. Использовать функциональный интерфейс `Supplier<P>` (фабрика) для создания целевой коллекции.  
2. Метод принимает `List<T>` и фабрику коллекции.  
3. Создать новую коллекцию через `factory.get()` и наполнить её данными из списка с помощью `addAll`.