# Отчет по Лабораторной работе №6
**Студент:** Чеповецкий Александр ИТ-7  
**Тема:** Инструментирование кода (Аннотации, Reflection API, Тестирование)

---

## Задание 1. Аннотации

### Задача 1. Аннотация @Invoke
**Текст задачи:**  
Разработать аннотацию `@Invoke` для методов, доступную во время исполнения. Создать обработчик через Reflection API, который автоматически находит и вызывает помеченные методы.  
**Алгоритм решения:**  
1. Создать аннотацию с `@Target(ElementType.METHOD)` и `@Retention(RetentionPolicy.RUNTIME)`.  
2. В классе-обработчике получить список всех методов объекта через `getDeclaredMethods()`.  
3. С помощью `isAnnotationPresent(Invoke.class)` проверить наличие метки.  
4. Вызвать метод через `method.invoke(obj)`, обработав возможные исключения доступа.

### Задача 2. Аннотация @Default
**Текст задачи:**  
Создать аннотацию `@Default` для типов или полей с обязательным свойством `value` типа `Class`. Обработчик должен выводить имя указанного класса.  
**Алгоритм решения:**  
1. Описать аннотацию с методом `Class<?> value()`.  
2. В обработчике использовать `getAnnotation(Default.class)` для получения экземпляра аннотации у класса или поля.  
3. Вывести результат работы метода `value().getName()`.

### Задача 3. Аннотация @ToString
**Текст задачи:**  
Разработать аннотацию `@ToString` для управления строковым представлением объекта. Позволить исключать конкретные поля из вывода с помощью свойства `Mode.NO`.  
**Алгоритм решения:**  
1. Создать аннотацию с перечислением (Enum) внутри (YES/NO).  
2. В обработчике через рефлексию обойти все поля объекта.  
3. Для каждого поля вызвать `setAccessible(true)`, чтобы получить значение приватных полей.  
4. Проверять: если поле помечено как `NO`, пропускать его. Остальные поля собирать в `StringBuilder`.

### Задача 4. Аннотация @Validate
**Текст задачи:**  
Создать аннотацию `@Validate`, принимающую массив классов. Обработчик должен выводить список этих классов.  
**Алгоритм решения:**  
1. Описать аннотацию со свойством `Class<?>[] value()`.  
2. В обработчике извлечь массив классов через объект аннотации.  
3. Использовать `Arrays.toString()` для удобного вывода списка всех типов, указанных для проверки.

### Задача 5. Аннотация @Two
**Текст задачи:**  
Создать аннотацию `@Two` с двумя обязательными свойствами: строкой и числом.  
**Алгоритм решения:**  
1. Описать свойства `String first()` и `int second()`.  
2. В обработчике считать значения этих свойств из аннотации класса и вывести их на экран в консоль.

### Задача 6. Аннотация @Cache
**Текст задачи:**  
Создать аннотацию `@Cache` для кэширования областей (массив строк). Если массив пуст — выводить соответствующее сообщение.  
**Алгоритм решения:**  
1. Описать аннотацию с параметром по умолчанию (пустой массив).  
2. В обработчике проверить длину полученного массива строк.  
3. Если `length == 0`, вывести «Cache empty», иначе перечислить все области.

---

## Задание 2. Тестирование

### Задача 3. Тест аннотации @Default (JUnit)
**Текст задачи:**  
Проверить корректность обработки `@Default` через JUnit, включая параметризованные тесты.  
**Алгоритм решения:**  
1. Использовать `assertTrue` и `isAnnotationPresent`, чтобы убедиться, что аннотация видна рефлексии.  
2. Применить `assertEquals` для сверки ожидаемого класса в `value()` с фактическим.  
3. Написать метод с `@ParameterizedTest` и `@ValueSource`, чтобы проверить работу аннотации на разных входных классах.

### Задача 5. Тест аннотации @Cache (JUnit)
**Текст задачи:**  
Реализовать тесты для проверки считывания кэшируемых сущностей.  
**Алгоритм решения:**  
1. Написать тест для проверки корректности длины массива в аннотации через `assertEquals`.  
2. Убедиться, что при пустом массиве данных логика программы не падает (обработка `null` или пустых коллекций).  
3. Проверить доступ к именованным областям кэша через `assertNotNull`.