# Отчет по Лабораторной работе №5
**Студент:** Чеповецкий Александр ИТ-7
**Тема:** Шаблоны ООП и Коллекции

## Задание 1. Шаблоны
### Задача 1. Дробь и Кэширование
**Текст задачи:**  
Создать интерфейс для сущности Дробь (получение вещественного значения, установка числителя и знаменателя). Реализовать версию дроби, которая кэширует вещественное значение. Дробь должна корректно обрабатывать отрицательные значения (знаменатель всегда положительный), иметь метод `toString` и переопределенный `equals` для сравнения по состоянию.

**Алгоритм решения:**
1. Создан интерфейс `FractionInterface` с необходимыми методами.
2. Реализован базовый класс `Fraction`. В сеттере знаменателя добавлена проверка на положительность и выбрасывание исключения. Метод `equals` сравнивает числитель и знаменатель.
3. Реализован класс `CachedFraction`, наследующийся от `Fraction`. В нем добавлено поле `Double cachedValue`.
4. В `CachedFraction` переопределен метод `getDecimalValue`: если кэш пуст, вычисляется значение и сохраняется. При вызове сеттеров кэш сбрасывается (`null`), чтобы при следующем запросе данные обновились.

---

## Задание 2. Структурные шаблоны
### Задача 1. Количество мяуканий (Декоратор)
**Текст задачи:**  
Используя класс Кот и интерфейс Мяуканье, необходимо подсчитать количество мяуканий кота, не изменяя исходный класс Кота.

**Алгоритм решения:**
1. Создан интерфейс `Meowable` с методом `meow()`.
2. Создан класс `Cat`, реализующий этот интерфейс.
3. Применен паттерн **Decorator (Wrapper)**: создан класс `MeowCounter`, который также реализует `Meowable` и принимает объект `Meowable` в конструкторе.
4. В методе `meow()` класса `MeowCounter` вызывается метод `meow()` обернутого объекта и инкрементируется внутренний счетчик. Это позволяет «подслушать» действия кота, не меняя его код.

---

## Задание 3. Список
### Задача 6. Удаление подряд идущих дубликатов
**Текст задачи:**  
В списке L из каждой группы подряд идущих одинаковых элементов оставить только один.

**Алгоритм решения:**
1. Метод принимает `List<T>`. 
2. Используется `Iterator` для безопасного удаления элементов во время обхода.
3. Сохраняется значение предыдущего элемента (`prev`). Если текущий элемент равен предыдущему (`Objects.equals`), он удаляется из списка методом `iterator.remove()`. Если не равен — текущий становится предыдущим.

---

## Задание 4. Мап (Map)
### Задача 5. Мониторинг цен на сметану
**Текст задачи:**  
На основе данных из файла (Фирма, Улица, Жирность, Цена) определить для каждого вида жирности (15%, 20%, 25%), сколько магазинов продают её по минимальной цене.

**Алгоритм решения:**
1. Созданы две структуры `Map<Integer, Integer>`: `minPrices` (хранит минимальную цену для каждой жирности) и `counts` (хранит количество магазинов с этой ценой).
2. Программа построчно читает файл. Для каждой строки извлекаются жирность и цена.
3. Если цена для данной жирности встречена впервые или она меньше текущей минимальной: обновляется `minPrices` и `counts` сбрасывается в 1.
4. Если цена равна текущей минимальной: инкрементируется значение в `counts`.
5. В конце выводятся значения из `counts` для ключей 15, 20 и 25.

---

## Задание 5. Сет (Set)
### Задача 9. Цифры в тексте
**Текст задачи:**  
Файл содержит текст на русском языке. Определить, какие цифры встречаются в тексте.

**Алгоритм решения:**
1. Файл считывается полностью в строку.
2. Используется `Set<Character> digits = new HashSet<>()` для хранения уникальных найденных цифр.
3. Строка переводится в массив символов. Для каждого символа проверяется условие `Character.isDigit(c)`.
4. Если символ — цифра, он добавляется в `Set`. Коллекция `Set` автоматически игнорирует повторы.

---

## Задание 6. Очередь
### Задача 3. Проверка соседей по кругу
**Текст задачи:**  
Определить, есть ли в очереди L хотя бы один элемент, который равен следующему за ним (первый элемент считается следующим для последнего).

**Алгоритм решения:**
1. Для удобства доступа по индексу очередь копируется в `ArrayList`.
2. Организуется цикл от 0 до `size - 1`.
3. Для каждого индекса `i` находится «следующий» индекс с помощью операции остатка от деления: `(i + 1) % size`. Это позволяет на последней итерации сравнить последний элемент с нулевым.
4. Если элементы равны, метод возвращает `true`.

---

## Задание 7. Стрим (Stream API)
### Задача 1. Обработка точек (Polyline)
**Текст задачи:**  
Из набора `Point` убрать дубликаты, убрать точки, где X=Y, отсортировать по X, сделать все Y положительными и собрать в `Polyline`.

**Алгоритм решения:**
1. Вызывается `stream()` по списку точек.
2. `.distinct()` — удаление дубликатов (на основе `equals` в `Point`).
3. `.filter(p -> p.getX() != p.getY())` — исключение точек на диагонали.
4. `.sorted(Comparator.comparingInt(Point::getX))` — сортировка.
5. `.map(p -> new Point(p.getX(), Math.abs(p.getY())))` — преобразование координат.
6. `.collect(Collectors.toList())` — сборка в список и инициализация объекта `Polyline`.

### Задача 2. Группировка людей из файла
**Текст задачи:**  
Прочитать файл (Имя:Номер), нормализовать имена (Первая заглавная, остальные строчные), убрать записи без номеров и сгруппировать имена по номерам.

**Алгоритм решения:**
1. `Files.lines()` — чтение файла потоком строк.
2. `.map(line -> line.split(":"))` — разделение строки на части.
3. `.filter(...)` — проверка, что массив содержит 2 элемента и номер не пуст.
4. `.collect(Collectors.groupingBy(...))` — группировка.
5. Внутри `groupingBy` в качестве ключа используется номер (`Integer.parseInt`), а в качестве значения — `Collectors.mapping`, который трансформирует имя (приведение к нижнему регистру и замена первой буквы на заглавную).